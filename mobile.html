<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Sidekick</title>
    <meta name="theme-color" content="#0b0f14" />
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #0f1620;
            --text: #e7eef7;
            --muted: #9fb2c6;
            --line: #1b2a3a;
            --accent: #7aa7ff;
            --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
            --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: var(--sans);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 32px;
            text-align: center;
            font-weight: 700;
        }

        .input-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            font-size: 13px;
            color: var(--muted);
            margin-bottom: 8px;
        }

        input,
        textarea {
            width: 100%;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 12px;
            color: var(--text);
            font-size: 15px;
            font-family: inherit;
        }

        input::placeholder,
        textarea::placeholder {
            color: var(--muted);
            opacity: 0.6;
        }

        textarea {
            min-height: 80px;
            resize: vertical;
            font-family: var(--sans);
        }

        input:focus,
        textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .btn {
            width: 100%;
            background: var(--accent);
            color: #000;
            border: none;
            border-radius: 12px;
            padding: 14px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 8px;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .response {
            margin-top: 24px;
            padding: 16px;
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: 12px;
            min-height: 200px;
            font-size: 15px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .response.empty {
            color: var(--muted);
            font-style: italic;
        }

        .error {
            color: #ff6b6b;
            font-size: 13px;
            margin-top: 8px;
        }

        .loading {
            color: var(--accent);
            font-size: 13px;
            margin-top: 8px;
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: block;
            width: 100%;
            background: var(--panel);
            border: 2px dashed var(--line);
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-label:hover {
            border-color: var(--accent);
        }

        .file-label.has-file {
            border-style: solid;
            border-color: var(--accent);
        }

        .preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 12px;
            display: none;
        }

        .preview.show {
            display: block;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Sidekick</h1>

        <div class="input-group">
            <label>Screenshot</label>
            <input type="file" id="imageFile" class="file-input" accept="image/*" onchange="handleFileSelect()">
            <label for="imageFile" class="file-label" id="fileLabel">
                <div id="labelText">üì∏ Tap to choose screenshot</div>
                <img id="preview" class="preview">
            </label>
        </div>

        <div class="input-group">
            <label for="userText">Message (optional)</label>
            <textarea id="userText" placeholder="Ask something about the screenshot..."></textarea>
        </div>

        <button class="btn" id="sendBtn" onclick="sendMessage()">Send</button>

        <div id="loading" class="loading" style="display:none">‚óè‚óè‚óè Streaming...</div>

        <div id="output" class="response empty">Response will appear here...</div>

        <div id="error" class="error"></div>
    </div>

    <script>
        const ENDPOINT = '/api/chat';
        const MODEL = 'Llama-4-Maverick-17B-128E-Instruct-FP8';
        const SYSTEM_PROMPT = `You are "Sidekick," a helpful assistant designed to analyze screenshots and provide human-like, contextual reactions. When a user shares a screenshot of:

- Text messages or social media feeds: React naturally, as if you're a friend reading over their shoulder. Offer honest takes, point out things that might be missed, suggest witty or empathetic replies (if relevant), or just vibe with the user about the content.
- Interface designs, dashboards, or UIs: Provide feedback on usability, aesthetics, clarity, or any obvious issues. Highlight what works well and what might confuse users.
- Error messages or technical screenshots: Explain what's wrong in plain language, suggest quick fixes or next steps, and reassure the user if it's a common/solvable issue.

Keep your tone casual, friendly, and conversational ‚Äî like texting a knowledgeable friend. Be concise by default but expand if the user asks follow-up questions. Don't just describe what you see; offer perspective, context, or actionable insights.`;

        let currentController = null;
        let currentImageData = null;

        function handleFileSelect() {
            const fileInput = document.getElementById('imageFile');
            const preview = document.getElementById('preview');
            const fileLabel = document.getElementById('fileLabel');
            const labelText = document.getElementById('labelText');
            const errorEl = document.getElementById('error');

            const file = fileInput.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                errorEl.textContent = 'Please select an image file';
                return;
            }

            errorEl.textContent = '';
            const reader = new FileReader();

            reader.onload = (e) => {
                currentImageData = e.target.result;
                preview.src = currentImageData;
                preview.classList.add('show');
                labelText.textContent = '‚úì ' + file.name;
                fileLabel.classList.add('has-file');
            };

            reader.readAsDataURL(file);
        }

        async function sendMessage() {
            const userText = document.getElementById('userText').value.trim();
            const outputEl = document.getElementById('output');
            const errorEl = document.getElementById('error');
            const loadingEl = document.getElementById('loading');
            const sendBtn = document.getElementById('sendBtn');

            // Clear previous state
            errorEl.textContent = '';
            outputEl.textContent = '';
            outputEl.classList.remove('empty');

            // Validate
            if (!currentImageData) {
                errorEl.textContent = 'Please select a screenshot first';
                return;
            }

            // Disable button
            sendBtn.disabled = true;
            loadingEl.style.display = 'block';

            // Build messages
            const content = [];
            if (userText) {
                content.push({
                    type: 'text',
                    text: userText
                });
            }
            content.push({
                type: 'image_url',
                image_url: { url: currentImageData }
            });

            const messages = [
                { role: 'system', content: SYSTEM_PROMPT },
                { role: 'user', content: content }
            ];

            // Stream request
            currentController = new AbortController();

            try {
                const response = await fetch(ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: MODEL,
                        messages: messages,
                        stream: true,
                        temperature: 0.6,
                        top_p: 0.9,
                        max_completion_tokens: 2048,
                        repetition_penalty: 1
                    }),
                    signal: currentController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullText = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') continue;

                            try {
                                const json = JSON.parse(data);
                                const delta = json.choices?.[0]?.delta?.content;
                                if (delta) {
                                    fullText += delta;
                                    outputEl.textContent = fullText;
                                }
                            } catch (e) {
                                console.warn('Parse error:', e);
                            }
                        }
                    }
                }

                loadingEl.style.display = 'none';
                sendBtn.disabled = false;

            } catch (err) {
                if (err.name === 'AbortError') {
                    errorEl.textContent = 'Request cancelled';
                } else {
                    errorEl.textContent = `Error: ${err.message}`;
                }
                loadingEl.style.display = 'none';
                sendBtn.disabled = false;
            }
        }

        // Allow Enter to send (but Shift+Enter for newlines)
        document.getElementById('userText').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    </script>
</body>

</html>